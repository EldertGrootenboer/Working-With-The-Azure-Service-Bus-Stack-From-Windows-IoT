# Working With The Azure Service Bus Stack From Windows IoT
Windows IoT is a stripped down Windows version specifically for running on low power IoT devices. This sample will show how we can use the Azure Service Bus stack for connecting our device to Azure, in this case a ships engine, and processing events in a secure way. We will send telemetry data to Event Hubs and use Queues to send out exception details. We will also want to be able to receive data from a management portal, but since IoT devices are low power devices, we want to spend as little as possible of our processing power on security. Therefore we will not expose our device directly on the internet, but instead will be retrieving our settings from a Topic, which means we only use outbound communication for setting up connectivity instead of exposing an endpoint. For the full scenario and details with this sample you can [check this blogpost](http://blog.eldert.net/iot-integration-of-things-connecting-raspberry-pi-2-to-azure/).

## Description
In my blogpost I have described how to set up a Raspberry Pi 2 with Windows IoT core and generate data from the device, as well as a complete description on how to set up the Azure entities we will be using and background information on these entities. For this example we will assume you have set up a Service Bus namespace, with a queue, topic and event hub, and have set up security on these. Once you have the IoT Core Project Templates installed in Visual Studio, we will start by creating a new IoT Background Application. This will generate our StartupTask class, which is the entrypoint of our application. Let’s start by creating a BackgroundTaskDeferral, which will make sure our applications keeps running in the background once it has started up. If we do not do this the application will close once it has finished its logic in the Run method.

```C#
public sealed class StartupTask : IBackgroundTask 
{ 
    // Needed to make sure the application keeps running in the background 
    private BackgroundTaskDeferral _backgroundTaskDeferral; 
  
    public void Run(IBackgroundTaskInstance taskInstance) 
    { 
        // Do not close application after startup 
        _backgroundTaskDeferral = taskInstance.GetDeferral(); 
    } 
}
```
 
Currently the WindowsAzure.ServiceBus package does not yet work with Windows Runtime, so instead we will be using the [Azure SB Lite](https://github.com/ppatierno/azuresblite) NuGet package created by Paolo Patierno. This library implements almost all methods from the full WindowsAzure.ServiceBus library, which means that if we already have some code you would like to re-use, it can most probably just copied over and will just work. We will now create a client which will be used to send the data generated by our device into Azure Event Hubs.

```C#
private readonly EventHubClient _eventHub = EventHubClient.CreateFromConnectionString("Endpoint=sb://eldertiot.servicebus.windows.net/;SharedAccessKeyName=fieldhubs;SharedAccessKey=xxxxxxxxxxxxxxxxxxxxx", "eventhubfieldhubs");
```

Next we are going to create a client which will be listening on the Topic we have created, and retrieve messages as they come in. We will be listening on a subscription called Hydra, which is the name of our ship.

```C#
private readonly SubscriptionClient _topic = SubscriptionClient.CreateFromConnectionString("Endpoint=sb://eldertiot.servicebus.windows.net/;SharedAccessKeyName=fieldhubs;SharedAccessKey=xxxxxxxxxxxxxxxxxxx", "topicengineadministration", "Hydra");
```

We will be sending data with information about our ship’s engine, so we will define an object representing this.

```C#
/// <summary> 
/// Class representing the information an engine would send out. 
/// To be able to serialize, we have to annotate class and it's members. 
/// </summary> 
[DataContract] 
internal class EngineInformation 
{ 
    [DataMember] 
    internal Guid Identifier; 
  
    [DataMember] 
    internal string ShipName; 
  
    [DataMember] 
    internal string EngineName; 
  
    [DataMember] 
    internal double Temperature; 
  
    [DataMember] 
    internal double RPM; 
  
    [DataMember] 
    internal bool Warning; 
  
    [DataMember] 
    internal int EngineWarning; 
  
    [DataMember] 
    internal DateTime CreatedDateTime; 
}
```
 
Before sending the data we will serialize it into an UTF8 encoded JSON string. There are some libraries out there which we can use to serialize to JSON, with Newtonsoft’s serializer probably being the most well-known, however this library currently does not work with WinRT, so we’ll create our serializing extension method.

```C#
/// <summary> 
/// Class used to serialize engine information to JSON. 
/// Created this due to issues with the NewtonSoft JSON serializer, probably will work with a future version. 
/// </summary> 
internal static class EngineInformationSerialization 
{ 
    internal static string Serialize(this EngineInformation engineInformation) 
    { 
        // Create a stream to serialize the object to 
        var memoryStream = new MemoryStream(); 
  
        // Serialize the object to the stream 
        var jsonSerializer = new DataContractJsonSerializer(typeof(EngineInformation)); 
        jsonSerializer.WriteObject(memoryStream, engineInformation); 
        memoryStream.Flush(); 
        var json = memoryStream.ToArray(); 
        return Encoding.UTF8.GetString(json, 0, json.Length); 
    } 
}
```
 
We are now ready to send out our readings from our sensors out to Azure Event Hubs. As we will want to process the data for a ship chronologically we will set a partition key with the name of our ship, to make sure this ends up in the same partition. This way the readings for different ships will end up in different partitions, but the data per ship is always in the same partition.

```C#
/// <summary> 
/// Get readings from sensors. 
/// </summary> 
private void GetSensorReadings() 
{ 
    // Get temperature from SHT15 
    // To simulate more realistic engine temperatures, we multiply it 
    var temperature = _sht15.CalculateTemperatureC(_sht15.ReadRawTemperature()) * 20; 
    Debug.WriteLine($"Temperature: {temperature}"); 
  
    // Check if a warning should be generated 
    var warning = temperature > _maximumTemperature; 
  
    try 
    { 
        // Create engine information object, simulate some of the input 
        var engineInformation = new EngineInformation 
        { 
     Identifier = Guid.NewGuid(), 
            ShipName = "Hydra", 
            EngineName = "Main Engine Port", 
            CreatedDateTime = DateTime.UtcNow, 
            RPM = new Random().Next(400, 1000), 
            Temperature = temperature, 
            Warning = warning, 
            EngineWarning = !_warningGenerated && new Random().Next(0, 10) > 9 ? new Random().Next(1, 3) : 0 
        }; 
  
        // Check if a warning was generated 
        if (engineInformation.EngineWarning > 0) 
        { 
            _warningGenerated = true; 
            Debug.WriteLine($"EngineWarning sent: {engineInformation.EngineWarning}"); 
        } 
  
        // Serialize to JSON 
        // With the current version (7.0.1) the Newtonsoft JSON serializer does not work, so created our own serializer 
        var serializedString = engineInformation.Serialize(); 
  
        // Create brokered message 
        // Send with shipname as partitionkey, to make sure messages for 1 ship are processed in correct order 
        var message = new EventData(Encoding.UTF8.GetBytes(serializedString)); 
        message.Properties.Add("haswarning", engineInformation.Warning); 
        message.PartitionKey = engineInformation.ShipName; 
  
        // Send to event hub 
        _eventHub.Send(message); 
    } 
    catch (Exception exception) 
    { 
        exception.Log(); 
    }
```

As you can see, there’s an extension method on the exception to log the exception. For local debugging you can use the debug console in Visual Studio, which will capture the exceptions from your connected device. However, once the device goes into the field this will no longer be an option, as these devices most probably will be working headless. We therefor will send the exception information to an Azure queue, from which we can use other clients to retrieve this information. To do this, we create a new static class, and define a queue client.

```C#
internal static class Exceptions 
{ 
    private static QueueClient _queue; 
  
    private static QueueClient Queue = _queue ?? (_queue = QueueClient.CreateFromConnectionString("Endpoint=sb://eldertiot.servicebus.windows.net/;SharedAccessKeyName=fieldhubs;SharedAccessKey=EDfKxxxxxxxxxxLZ2cA=", "queueerrorsandwarnings")); 
}
```

And create an extension method which will use this client use this client to write our excceptions to the queue.

```C#
public static void WriteToServiceBusQueue(this Exception exception) 
{ 
    var message = new BrokeredMessage(); 
    message.Properties["ship"] = "Hydra"; 
    message.Properties["time"] = DateTime.UtcNow; 
    message.Properties["exceptionmessage"] = exception.ToString(); 
    Queue.Send(message); 
} 
  
public static void Log(this Exception exception) 
{ 
    Debug.WriteLine(exception.ToString()); 
    exception.WriteToServiceBusQueue(); 
}
```
 
Now we will go back to the Run method in our StartupTask class, and create a timer which will retrieve our sensor readings every 5 seconds, and send them to Azure Event Hubs.

```C#
// Set task to be run in background 
ThreadPoolTimer.CreatePeriodicTimer(timer =&gt; 
{ 
    GetSensorReadings(); 
}, new TimeSpan(0, 0, 5));
```

The final step for this part is to add a listener on the subscription we created on the topic, which will listen for incoming messages. Add the following code in the Run method for this.

```C#
// Trigger for receiving messages from a topic 
_topic.OnMessage(message => { 
    var newMaximumTemperature = message.Properties["maximumtemperature"]; 
    _maximumTemperature = Convert.ToInt32(newMaximumTemperature); 
    Debug.WriteLine($"Maximum temperature has been set to {newMaximumTemperature}"); 
});
```

That’s it, we can now publish our solution to our device, and see events being generated and sent to Azure.

## More Information
This sample is part of a series I have written around IoT, the full scenario and details [with this sample](http://blog.eldert.net/iot-integration-of-things-connecting-raspberry-pi-2-to-azure/) can be found on [my blog](http://blog.eldert.net/), as well as the other related posts.
